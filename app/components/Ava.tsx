/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/model/girl.glb -o app/components/Avatar.tsx -r public 
*/

import * as THREE from 'three';
import React, { useRef, useEffect, useState, useMemo } from 'react';
import { useFrame, useGraph } from '@react-three/fiber';
import { useAnimations, useFBX, useGLTF } from '@react-three/drei';
import { GLTF, SkeletonUtils } from 'three-stdlib';
import { useSinging } from '../context/sing';
import { MouthCue } from '../context/sing';

type GLTFResult = GLTF & {
  nodes: {
    Wolf3D_Hair: THREE.SkinnedMesh;
    Wolf3D_Body: THREE.SkinnedMesh;
    Wolf3D_Outfit_Bottom: THREE.SkinnedMesh;
    Wolf3D_Outfit_Footwear: THREE.SkinnedMesh;
    Wolf3D_Outfit_Top: THREE.SkinnedMesh;
    EyeLeft: THREE.SkinnedMesh;
    EyeRight: THREE.SkinnedMesh;
    Wolf3D_Head: THREE.SkinnedMesh;
    Wolf3D_Teeth: THREE.SkinnedMesh;
    Hips: THREE.Bone;
  };
  materials: {
    Wolf3D_Hair: THREE.MeshStandardMaterial;
    Wolf3D_Body: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Bottom: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Footwear: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Top: THREE.MeshStandardMaterial;
    Wolf3D_Eye: THREE.MeshStandardMaterial;
    Wolf3D_Skin: THREE.MeshStandardMaterial;
    Wolf3D_Teeth: THREE.MeshStandardMaterial;
  };
  // animations: GLTFAction[]
};

interface Lipsync {
  mouthCues: MouthCue[];
}

const visemesMapping: { [key: string]: string } = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

export function Avatar(props: JSX.IntrinsicElements['group']) {
  const { scene } = useGLTF('/model/girl.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult;
  const { mouthCue, currentTime, isPlaying, audioRef } = useSinging();
  // const { animations: happy } = useFBX("/animations/Happy.fbx");
  // const { animations: singing } = useFBX("/animations/Singing.fbx");
  // const { animations: breakdanceReady } = useFBX("/animations/BreakdanceReady.fbx");
  // const { animations: turn180 } = useFBX("/animations/180 Turn W_ Briefcase.fbx");
  // const { animations: armStretching } = useFBX("/animations/Arm Stretching.fbx");
  // const { animations: blowAKiss } = useFBX("/animations/Blow A Kiss.fbx");
  // const { animations: catWalk } = useFBX("/animations/Catwalk Walk Forward.fbx");
  // const { animations: happyHandGesture } = useFBX("/animations/Happy Hand Gesture.fbx");
  // const { animations: idle } = useFBX("/animations/Idle.fbx");
  // const { animations: listeningToMusic } = useFBX("/animations/Listening To Music.fbx");
  // const { animations: neckStretching } = useFBX("/animations/Neck Stretching.fbx");
  // const { animations: rightTurn } = useFBX("/animations/Right Turn.fbx");
  // const { animations: shakingHeadNo } = useFBX("/animations/Shaking Head No.fbx");
  // const { animations: talking } = useFBX("/animations/Talking.fbx");
  // const { animations: turning } = useFBX("/animations/Turning.fbx");
  // const { animations: victoryIdle } = useFBX("/animations/Victory Idle.fbx");

  // happy[0].name = "Happy";
  // singing[0].name = "Singing";
  // breakdanceReady[0].name = "BreakdanceReady";
  // turn180[0].name = "180 Turn W_ Briefcase";
  // armStretching[0].name = "Arm Stretching";
  // blowAKiss[0].name = "Blow A Kiss";
  // catWalk[0].name = "Catwalk Walk Forward";
  // happyHandGesture[0].name = "Happy Hand Gesture";
  // idle[0].name = "Idle";
  // listeningToMusic[0].name = "Listening To Music";
  // neckStretching[0].name = "Neck Stretching";
  // rightTurn[0].name = "Right Turn";
  // shakingHeadNo[0].name = "Shaking Head No";
  // talking[0].name = "Talking";
  // turning[0].name = "Turning";
  // victoryIdle[0].name = "Victory Idle";

  // const [animation, setAnimation] = useState("Happy");
  // const group = useRef<THREE.Group>(null);
  // const { actions } = useAnimations([
  //   happy[0], 
  //   singing[0], 
  //   breakdanceReady[0],
  //   turn180[0],
  //   armStretching[0],
  //   blowAKiss[0],
  //   catWalk[0],
  //   happyHandGesture[0],
  //   idle[0],
  //   listeningToMusic[0],
  //   neckStretching[0],
  //   rightTurn[0],
  //   shakingHeadNo[0],
  //   talking[0],
  //   turning[0],
  //   victoryIdle[0]
  // ], group);

  // useEffect(() => {
  //   console.log(animation);
  //   actions[animation]?.reset().fadeIn(0.5).play();
    
  //   return () => {
  //     actions[animation]?.fadeOut(0.5);
  //   };
  // }, [animation]);

  useEffect(() => { 
    if (isPlaying) {
      setAnimation("Singing");
    } else {
      setAnimation("Happy");
    }
  }, [isPlaying]);

  const { animations } = useGLTF("/animations/animations.glb");

  const group = useRef<THREE.Group>(null);
  const { actions, mixer } = useAnimations(animations, group);
  const [animation, setAnimation] = useState(
    animations.find((a) => a.name === "Happy") ? "Happy" : animations[0].name // Check if Idle animation exists otherwise use first animation
  );

  useEffect(() => {
    const action = actions[animation];
    if (action) {
      action.reset();
      action.fadeIn(0.5).play();
    }
    return () => {
      if (action) {
        action.fadeOut(0.5);
      }
    };
  }, [animation]);


//   const animationSequence = useRef([
//     "Happy",
//     "Singing",
//     "BreakdanceReady",
//     "180 Turn W_ Briefcase",
//     "Blow A Kiss",
//     "Catwalk Walk Forward",
//     "Happy Hand Gesture",
//     "Listening To Music",
//     "Right Turn",
//     "Shaking Head No",
//     "Talking",
//     "Turning",
//     "Victory Idle"
//   ]);

//   const getRandomAnimation = () => {
//     const randomIndex = Math.floor(Math.random() * animationSequence.current.length);
//     return animationSequence.current[randomIndex];
//   };

//   const playNextAnimation = () => {
//     const nextAnimation = getRandomAnimation();
//     setAnimation(nextAnimation);
//   };

  useFrame(() => {
  if (audioRef.current?.ended) {
    setAnimation("Happy");
    return;
  }

  if (isPlaying && mouthCue.length > 0) {
    Object.keys(visemesMapping).forEach((value) => {
      if (nodes.Wolf3D_Head.morphTargetInfluences && nodes.Wolf3D_Head.morphTargetDictionary) {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
      if (nodes.Wolf3D_Teeth.morphTargetInfluences && nodes.Wolf3D_Teeth.morphTargetDictionary) {
        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
    });

    const currentAudioTime = currentTime;
    for (let i = 0; i < mouthCue.length; i++) {
      const mouthCueItem = mouthCue[i];
      if (currentAudioTime >= mouthCueItem.start && currentAudioTime <= mouthCueItem.end) {
        const viseme = visemesMapping[mouthCueItem.value];
        if (nodes.Wolf3D_Head.morphTargetInfluences && nodes.Wolf3D_Head.morphTargetDictionary) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = 1;
        }
        if (nodes.Wolf3D_Teeth.morphTargetInfluences && nodes.Wolf3D_Teeth.morphTargetDictionary) {
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = 1;
        }
        break;
      }
    }
  }

  if (!isPlaying) {
    Object.keys(visemesMapping).forEach((value) => {
      if (nodes.Wolf3D_Head.morphTargetInfluences && nodes.Wolf3D_Head.morphTargetDictionary) {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
      if (nodes.Wolf3D_Teeth.morphTargetInfluences && nodes.Wolf3D_Teeth.morphTargetDictionary) {
        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
    });
  }
});

//   useEffect(() => {
//     if (actions && actions[animation]) {
//       const animationAction = actions[animation];
//       const clip = animationAction?.getClip();
  
//       console.log(animation);

//       // Ensure clip and its duration are defined
//       if (clip && clip.duration) {
//         animationAction?.reset().fadeIn(0.5).play();
//         const duration = clip.duration * 1000;
  
//         const timeoutId = setTimeout(() => {
//           // animationAction.fadeOut(0.5);
//           playNextAnimation();
//         }, duration);
  
//         return () => {
//           clearTimeout(timeoutId);
//           animationAction?.fadeOut(0.5);
//         };
//       } else {
//         console.warn('Animation clip or duration is undefined.');
//       }
//     }
//   }, [animation]);

  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
      <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
      <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
      <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} />
      <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
    </group>
  );
}