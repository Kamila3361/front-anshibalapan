/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/model/girl.glb -o app/components/Avatar.tsx -r public 
*/

import * as THREE from 'three';
import React, { useRef, useEffect, useState, useMemo } from 'react';
import { useFrame, useGraph } from '@react-three/fiber';
import { useAnimations, useFBX, useGLTF } from '@react-three/drei';
import { GLTF, SkeletonUtils } from 'three-stdlib';
import { useSinging } from '../context/sing';
import { MouthCue } from '../context/sing';

type GLTFResult = GLTF & {
  nodes: {
    Wolf3D_Hair: THREE.SkinnedMesh;
    Wolf3D_Body: THREE.SkinnedMesh;
    Wolf3D_Outfit_Bottom: THREE.SkinnedMesh;
    Wolf3D_Outfit_Footwear: THREE.SkinnedMesh;
    Wolf3D_Outfit_Top: THREE.SkinnedMesh;
    EyeLeft: THREE.SkinnedMesh;
    EyeRight: THREE.SkinnedMesh;
    Wolf3D_Head: THREE.SkinnedMesh;
    Wolf3D_Teeth: THREE.SkinnedMesh;
    Hips: THREE.Bone;
  };
  materials: {
    Wolf3D_Hair: THREE.MeshStandardMaterial;
    Wolf3D_Body: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Bottom: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Footwear: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Top: THREE.MeshStandardMaterial;
    Wolf3D_Eye: THREE.MeshStandardMaterial;
    Wolf3D_Skin: THREE.MeshStandardMaterial;
    Wolf3D_Teeth: THREE.MeshStandardMaterial;
  };
  // animations: GLTFAction[]
};

const visemesMapping: { [key: string]: string } = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

export function Avatar(props: JSX.IntrinsicElements['group']) {
  const { scene } = useGLTF('/model/girl.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult;
  const { mouthCue, currentTime, isPlaying, audioRef, animation, setAnimation } = useSinging();
  const [index, setIndex] = useState(0);

  useEffect(() => { 
    if (isPlaying && currentTime >= mouthCue[index].start && currentTime <= mouthCue[index].end) {
      if(mouthCue[index].end - mouthCue[index].start > 3 && mouthCue[index].value === "X"){
        setAnimation("Happy");
      } else {
        setAnimation("Singing");
      }
      console.log(index);
    } if (!isPlaying) {
      setAnimation("Happy");
    }
  }, [isPlaying, index, currentTime, mouthCue]);

  const { animations } = useGLTF("/animations/animations5.glb");

  const group = useRef<THREE.Group>(null);
  const { actions, mixer } = useAnimations(animations, group);
  // const [animation, setAnimation] = useState("Happy");

  useEffect(() => {
    const action = actions[animation];
    if (action) {
      action.reset();
      action.fadeIn(0.5).play();
    }
    return () => {
      if (action) {
        action.fadeOut(0.5);
      }
    };
  }, [animation, actions]);

  // const animationSequence = [
  //   "KissBlow",
  //   "Happy",
  //   "BreakDanceReady",
  //   "HappyHand",
  //   "ListeningMusic",
  //   "ShackingHead",
  //   "Talking",
  //   "VictoryIdle",
  // ];

  // const playNextAnimation = () => {
  //   const nextIndex = Math.floor(Math.random() * animationSequence.length);
  //   const nextAnimation = animationSequence[nextIndex];
  //   console.log("nextAnimation: ", nextAnimation);
  //   setIndex(index + 1);
  //   setAnimation(nextAnimation);
  // };

  // useEffect(() => {
  //   if (isPlaying && actions && actions[animation]) {
  //     const animationAction = actions[animation];
  //     const clip = animationAction?.getClip();
  
  //     console.log(animation);

  //     // Ensure clip and its duration are defined
  //     if (clip && clip.duration) {
  //       animationAction?.reset().fadeIn(0.5).play();
  //       const duration = clip.duration * 1000;
  
  //       const timeoutId = setTimeout(() => {
  //         // animationAction.fadeOut(0.5);
  //         playNextAnimation();
  //       }, duration);
  
  //       return () => {
  //         clearTimeout(timeoutId);
  //         animationAction?.fadeOut(0.5);
  //       };
  //     } else {
  //       console.warn('Animation clip or duration is undefined.');
  //     }
  //   }
  // }, [animation, index, isPlaying]);

  useFrame(() => {
  if (audioRef.current?.ended) {
    setAnimation("Happy");
    return;
  }

  if (isPlaying && mouthCue.length > 0) {
    Object.keys(visemesMapping).forEach((value) => {
      if (nodes.Wolf3D_Head.morphTargetInfluences && nodes.Wolf3D_Head.morphTargetDictionary) {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
      if (nodes.Wolf3D_Teeth.morphTargetInfluences && nodes.Wolf3D_Teeth.morphTargetDictionary) {
        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
    });

    const currentAudioTime = currentTime;
    for (let i = 0; i < mouthCue.length; i++) {
      setIndex(i);
      const mouthCueItem = mouthCue[i];
      if (currentAudioTime >= mouthCueItem.start && currentAudioTime <= mouthCueItem.end) {
        const viseme = visemesMapping[mouthCueItem.value];
        if (nodes.Wolf3D_Head.morphTargetInfluences && nodes.Wolf3D_Head.morphTargetDictionary) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = 1;
        }
        if (nodes.Wolf3D_Teeth.morphTargetInfluences && nodes.Wolf3D_Teeth.morphTargetDictionary) {
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = 1;
        }
        break;
      }
    }
  }

  if (!isPlaying) {
    Object.keys(visemesMapping).forEach((value) => {
      if (nodes.Wolf3D_Head.morphTargetInfluences && nodes.Wolf3D_Head.morphTargetDictionary) {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
      if (nodes.Wolf3D_Teeth.morphTargetInfluences && nodes.Wolf3D_Teeth.morphTargetDictionary) {
        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[visemesMapping[value]]
        ] = 0;
      }
    });
  }
});

  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
      <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
      <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
      <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} />
      <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
    </group>
  );
}
